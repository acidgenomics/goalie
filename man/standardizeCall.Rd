% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/base-standardizeCall.R
\name{standardizeCall}
\alias{standardizeCall}
\title{Standardize call}
\usage{
standardizeCall(which = sys.parent(n = 1L), defaults = TRUE,
  expandDots = TRUE, return = c("call", "list"), verbose = FALSE)
}
\arguments{
\item{which}{the frame number if non-negative, the number of frames
    to go back if negative.}

\item{defaults}{\code{logical(1)}.
Include default arguments in the call.}

\item{expandDots}{\code{logical(1)}.
Should arguments matching \code{...} in the call be included or left as a
\code{...} argument?}

\item{return}{\code{character(1)}.
Return type. Uses \code{\link[base:match.arg]{match.arg()}} internally and defaults
to the first argument in the \code{character} vector.}

\item{verbose}{\code{logical(1)}.
Run the function with verbose output.}
}
\value{
\itemize{
\item \code{call}: Matched call.
\item \code{list}: Verbose list that includes additional information about how the
call was standardized. Recommended for debugging purposes only.
}
}
\description{
This function adds matching support for S4 methods with formals that aren't
identical to the generic, and use a nested \code{.local} call.
}
\note{
Updated 2019-08-08.
}
\examples{
aaa <- "AAA"
bbb <- "BBB"

## Standard function.
testing <- function(a, b) {
    standardizeCall()
}
testing(aaa, bbb)

## Inside S4 method.
setGeneric(
    name = "testing",
    def = function(a, b, ...) {
        standardGeneric("testing")
    }
)

setMethod(
    f = "testing",
    signature = signature("character"),
    definition = function(a, b, ...) {
        standardizeCall()
    }
)
testing(aaa, bbb)
}
\seealso{
\itemize{
\item \code{match.call()}.
\item \code{sys.call()}.
\item \code{sys.parent()}.
\item \code{pryr::standardise_call()}.
\item \code{stackoverflow::match.call.defaults()}.
}
}
